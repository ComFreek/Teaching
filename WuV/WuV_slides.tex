\documentclass{beamer}
\usepackage{graphicx}

\usepackage{url}

\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{xkeyval}

\usepackage{../macros/mytikz}
\usepackage{listings}
\lstset{mathescape}

\usepgflibrary{shapes}
\usepackage{stmaryrd}

\usepackage{../macros/basics}
\usepackage{../macros/basics-slides}
%\usepackage{../macros/mmt_listings}
\usepackage{../macros/twelf-math}

\usepackage{../macros}
\usepackage{macros}


\newcommand{\lf}{\mathit{LF}}
\newcommand{\kity}{\mathit{type}}


\renewcommand{\emph}[1]{\alert{#1}}

%\setbeamertemplate{headline}{\small\hfill\insertsection \hfill\hbox{}}

\begin{document}

\title{Knowledge Representation and Processing}
\author{Florian Rabe (for a course given with Michael Kohlhase)}
\institute{Computer Science, University Erlangen-N\"urnberg, Germany}
\date{Summer 2020}
\begin{frame}
    \titlepage
\end{frame}

\input{WuV_slides_body}

\section{Absolute Semantics for BOL}

\begin{frame}\frametitle{Judgments}
Typing:  \[\Gamma\vdash^{BOL}_V e:E\]
Deduction: \[\Gamma\vdash^{BOL}_V F\]

Propositions $\prop$:
\begin{itemize}
\item $C\sqsubseteq D$, $C\Equiv D$
\item all three kinds of assertions
\end{itemize}

Notation:
\begin{itemize}
\item We drop the superscript $^{BOL}$ everywhere.
\item We drop the subscript $_V$ unless we need to use $V$.
\item We drop the context $\Gamma$ unless we need to use/change $\Gamma$.
\end{itemize}
\end{frame}

\begin{frame}\frametitle{Typing}
Trivial intrinsic typing (Church) $\vdash e:^{int} E$
\begin{itemize}
\item $E$ is a non-terminal
\item $e$ an expression derived from $E$
\end{itemize}
\medskip

Refined by extrinsic typing (Curry) $\vdash e :^{ext} E$
\begin{itemize}
\item $e$ is an individual, i.e., $\vdash e :^{int} I$
\item $E$ is a concept, i.e., $\vdash E :^{int} C$
 \glec{where $I$ and $C$ are the non-terminals from the grammar}
\item $e$ has concept $E$, i.e., $\vdash e \isa E$
\end{itemize}
\end{frame}

\begin{frame}\frametitle{Propositions as Types}
Say also $\vdash p:f$ for proofs $p$ of proposition $f$
\lec{in particular: $x:f$ in contexts to make local assumptions}
\medskip

Notation:
\[\Gamma,\; f \tb\text{instead of} \tb \Gamma,\;p:f\]
\glec{sufficient if we only state the rules, not build proofs}
\end{frame}

\begin{frame}\frametitle{Lookup Rules}
The main rules that need to access the vocabulary:
\[\rul{f\minn V}{\vdash_V f}\]
\glec{for assertions or axioms f}
\medskip

Assumptions in the context are looked up accordingly:
\[\rul{x:f\minn \Gamma}{\Gamma\vdash f}\]
\end{frame}

\begin{frame}\frametitle{Rules for Subsumption and Equality}
Subsumption is an order with respect to equality:
\[\rul{}{\vdash c\sqsubseteq c}\]

\[\rul{\vdash c\sqsubseteq d \tb \vdash d\sqsubseteq e}{\vdash c\sqsubseteq e}\]

\[\rul{\vdash c\sqsubseteq d \tb \vdash d\sqsubseteq c}{\vdash c\Equiv d}\]

Equal concepts can be substituted for each other:
\[\rul{\vdash c\Equiv d\tb x:C\vdash f(x):\prop \tb \vdash f(c)}{f(d)}\]

\glec{This completely defines equality.}
\end{frame}

\begin{frame}\frametitle{Rules relating Instancehood and Subsumption}
\[\rul{\vdash i\isa c \tb \vdash c\sqsubseteq d}{\vdash i\isa d}\]
Read:
\begin{itemize}
\item if
 \begin{itemize}
 \item $i\isa c$
 \item $c\sqsubseteq d$
 \end{itemize}
\item then $i\isa d$
\end{itemize}

\[\rul{x:I,\,x\isa c\vdash x\isa d}{\vdash c\sqsubseteq d}\]
Read:
\begin{itemize}
\item if
 \begin{itemize}
 \item assuming an individual $x$ and $x\isa c$, then $x\isa d$
 \end{itemize}
\item then $c\sqsubseteq d$
\end{itemize}
\end{frame}

\begin{frame}\frametitle{Induction}
Consider from before
\[\rul{x:I,\,x\isa c\vdash x\isa d}{\vdash c\sqsubseteq d}\]

Question: Do we allow proving the hypothesis by checking for each individual $x$?
 \lec{induction}
\begin{itemize}
\item<2-> Open world: no
\item<3-> Closed world: yes
 \[\rul{\Gamma[x=i]\vdash f[x=i] \;\text{ for every individual } i}{\Gamma, x:I\vdash f(x)}\]
 \glec{effectively applicable if only finitely many individuals}
\end{itemize}
\end{frame}

\begin{frame}\frametitle{Rules for Union and Intersection of Concepts}
Union as the least upper bound:
\[\rul{}{\vdash c\sqsubseteq c\sqcup d} \tb\tb \rul{}{\vdash d\sqsubseteq c\sqcup d }\]
\[\rul{\vdash c\sqsubseteq h \tb \vdash d\sqsubseteq h}{\vdash c\sqcup d \sqsubseteq h}\]
\medskip

Dually, intersection as the greatest lower bound:
\[\rul{}{\vdash c\sqcap d\sqsubseteq c} \tb\tb \rul{}{\vdash c\sqcap d\sqsubseteq d}\]
\[\rul{\vdash h\sqsubseteq c \tb \vdash h\sqsubseteq d}{\vdash h \sqsubseteq c\sqcap d}\]
\end{frame}

\begin{frame}\frametitle{Rules for Existential and Universal}
Easy rules:
\begin{itemize}
\item Existential
\[\rul{\vdash i\,r\,j \tb \vdash j\isa c}{\vdash i \isa \exists r.c }\]
\item Universal
\[\rul{\vdash i \isa \forall r.c \tb \vdash i\,r\,j}{\vdash j\isa c}\]
\end{itemize}

Other directions are trickier:

\begin{itemize}
\item Existential
\[\rul{\vdash i \isa \exists r.c \tb j:I,\;i\,r\,j,\;j\isa c\vdash f}{\vdash f}\]
\item Universal
\[\rul{j:I,\; i\,r\,j\vdash j\isa c}{\vdash i\isa\forall r.c}\]
\end{itemize}
\end{frame}

\begin{frame}\frametitle{Selected Rules for Relations}
Inverse:
\[\rul{\vdash i \,r\,j}{\vdash j\,r^{-1}\,i}\]

Composition:
\[\rul{\vdash i \,r\,j \tb \vdash j\,s\,k}{\vdash i\,(r;s)\,k}\]

Transitive closure:
\[\rul{}{\vdash i \,r^*\,i} \tb \rul{\vdash i\,r\,j \tb \vdash j\,r^* k}{\vdash i\,r^* k}\]

Identity at concept $c$:
\[\rul{\vdash i \isa c}{\vdash i\,\Delta_c i}\]
\end{frame}

\section{Equivalence of BOL Semantics}

\begin{frame}\frametitle{Overview}
Now $5$ semantics for BOL
\begin{itemize}
\item absolute deductive via calculus
\item relative deductive via SFOL
\item relative computational via Scala
\item relative concrete via SQL
\item relative narrative via English
\end{itemize}
Moreover, these are interdefinable.
\glec{e.g., Scala translation also induces deductive semantics}

Can compare equivalence
\begin{itemize}
\item for every pair of semantics
\item for every kind of equivalence (deductive, concrete, computational)
\end{itemize}
Question: Which of them hold?
\end{frame}

\begin{frame}\frametitle{Breakout Questions}
For example, consider:
\begin{itemize}
\item Are the two deductive semantics deductively equivalent?
\item Are the absolute semantics and the Scala semantics deductively equivalent?
\item Assuming BOL and SQL have the base types and values:
Are the absolute semantics and the SQL semantics concretely equivalent?
\end{itemize}
\end{frame}

\begin{frame}\frametitle{Deductive Equivalence}
Translation $\sem{-}$ to SFOL
\begin{itemize}
\item soundness: $\vdash^{BOL}_V f$ implies $\vdash^{SFOL}_{\sem{V}}\sem{f}$
 \glec{induction not sound}
\item completeness: $\vdash^{BOL}_V f$ implied by $\vdash^{SFOL}_{\sem{V}}\sem{f}$
 \glec{holds if we add missing rules}
\end{itemize}
\end{frame}

\begin{frame}\frametitle{Problem: Consequence Closure}
Absolute semantics performs consequence closure, e.g.,
\begin{itemize}
\item transitivity of $\sqsubseteq$
\item relationship between $\sqsubseteq$ and $\isa$
\end{itemize}
\medskip

Scala semantics only if we explicitly implemented it
\glec{we didn't}
\medskip

Same problem for SQL semantics
\end{frame}

\begin{frame}\frametitle{Problem: Closed World}
Absolute semantics leaves open/closed world optional
\begin{itemize}
\item open by default
\item closed if we add the induction rule
\end{itemize}

Scala, SQL semantics automatically closed
\glec{only computable for finite worlds}
\end{frame}


\begin{frame}\frametitle{Problem: Computation}
Scala, SQL semantics evaluates concepts to
\begin{itemize}
\item SQL: tables of individuals
\item Scala: hashsets of individuals
\end{itemize}
\glec{only computable for finite worlds}

Deductive semantics Computational semantics leaves open/closed world optional
\begin{itemize}
\item open by default
\item closed if we add the induction rule
\end{itemize}

\end{frame}


\end{document}

