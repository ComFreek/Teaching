\documentclass{beamer}
\usepackage{graphicx}

\usepackage{url}

\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{xkeyval}

\usepackage{../macros/mytikz}
\usepackage{listings}
\lstset{mathescape}

\usepgflibrary{shapes}
\usepackage{stmaryrd}

\usepackage{../macros/basics}
\usepackage{../macros/basics-slides}
%\usepackage{../macros/mmt_listings}
\usepackage{../macros/twelf-math}

\usepackage{macros}
\usepackage{../macros}

\newcommand{\lf}{\mathit{LF}}
\newcommand{\kity}{\mathit{type}}


\renewcommand{\emph}[1]{\alert{#1}}

%\setbeamertemplate{headline}{\small\hfill\insertsection \hfill\hbox{}}

\begin{document}

\title{Knowledge Representation and Processing}
\author{Florian Rabe (for a course given with Michael Kohlhase)}
\institute{Computer Science, University Erlangen-N\"urnberg, Germany}
\date{Summer 2020}
\begin{frame}
    \titlepage
\end{frame}

\section{Administrative Information}

\begin{frame}\frametitle{Format}
\begin{blockitems}{Zoom}
\item lectures and exercises via zoom
\item participants muted by default for simplicity
\item interaction strongly encouraged
 \lec{We don't want to lecture ---}
 \lec{we want to have a conversation during which you learn}
\item let's try out zoom
 \begin{itemize}
 \item use reactions to say yes no, ask for break etc.
 \item feel free to annotate my slides
 \item talk in the chat
 \end{itemize}
\end{blockitems}

\begin{blockitems}{Recordings}
\item maybe prerecorded video lectures or recorded zoom meeting
\item to be decided along the way
\end{blockitems}
\end{frame}


\begin{frame}\frametitle{Background}
\begin{blockitems}{Instructors}
\item Prof. Dr. Michael Kohlhase \lec{Professor of Knowledge Representation and Processing}
\item PD Dr. Florian Rabe \lec{same research group}
\end{blockitems}

\begin{blockitems}{Course}
\item This course is given for the first time
\item Always a little bit of an experiment
  \lec{cutting edge vs. unpolished}
\item Could become signature course of our research group \lec{same name!}
\end{blockitems}
\end{frame}

\begin{frame}\frametitle{Prerequisites}
\begin{blockitems}{Required}
\item basic knowledge about formal languages, context-free grammars
 \lec{but we'll do a quick revision here}
\end{blockitems}

\begin{blockitems}{Helpful}
\item Algorithms and Data Structures
 \lec{mostly as a contrast to this lecture}
\item Basic logic
 \lec{we'll revise it slightly differently here}
\item all other courses
 \lec{as examples of how knowledge pervades all of CS}
\end{blockitems}

\begin{blockitems}{General}
\item Curiosity \lec{this course is a bit unusual}
\item Interest in big picture \lec{this course touches on lots of things from all over CS}
\end{blockitems}
\end{frame}

\begin{frame}\frametitle{Examination and Grading}
\begin{blockitems}{Suggestion}
\item grade determined by single exam
\item written or oral \lec{depends on number of students}
\item some acknowledgment for practical exercises
\end{blockitems}
\lec{to be finalized next week}

\begin{blockitems}{Exam-relevant}
\item anything mentioned in notes
\item anything discussed in lectures
\end{blockitems}
\lec{neither is a superset of the other!}
\end{frame}

\begin{frame}\frametitle{Materials and Exam-Relevance}
\begin{blockitems}{Textbook}
\item does not exist
\item normal for research-near specialization courses
\end{blockitems}

\begin{blockitems}{Notes}
\item textbook-style but not as comprehensive
\item developed along the way
\end{blockitems}

\begin{blockitems}{Slides}
\item not comprehensive
\item used as visual aid, conversation starters
\end{blockitems}
\end{frame}

\begin{frame}\frametitle{Communication}
\begin{blockitems}{Open for questions}
\item open door policy in our offices
  \glec{if the lockdown ever ends}
\item always room for questions during lectures
\item for personal questions, contact me during/after lecture or by email
\item forum at \url{https://fsi.cs.fau.de/forum/154-Wissensrepraesentation-und-Verarbeitung}
\end{blockitems}

\begin{blockitems}{Materials}
\item official notes and slides as pdf: \url{https://kwarc.info/teaching/WuV/}
 \lec{will be updated from time to time}
\item watch me prepare the materials: \url{https://github.com/florian-rabe/Teaching/tree/master/WuV}
 \lec{pull requests and issues welcome}
\end{blockitems}
\end{frame}

\begin{frame}\frametitle{Exercises}
\begin{blockitems}{Learning Goals}
\item Get acquainted with state of the art of practice
\item Try out real tools
\end{blockitems}

\begin{blockitems}{Homeworks}
\item one major project as running example
\item homeworks building on each other
\end{blockitems}
\lec{build one large knowledge-based system}
\lec{details on later slides}
\end{frame}

\section{Overview and Essential Concepts}

\begin{frame}\frametitle{Representation and Processing}
Common pairs of concepts:
\begin{center}
\begin{tabular}{l|l}
Representation & Processing \\
\hline
Static & Dynamic \\
Situation & Change \\
Be & Become \\
Data Structures & Algorithms \\
Set & Function \\
State & Transition \\
Space & Time
\end{tabular}
\end{center}
\end{frame}

\begin{frame}\frametitle{Data and Knowledge}
$2\times 2$ key concepts
\begin{center}
\begin{tabular}{l|l}
Syntax & Data \\
\hline
Semantics & Knowledge
\end{tabular}
\end{center}

\begin{itemize}
\item Data: any object that can be stored in a computer\\
 Example: $((49.5739143, 11.0264941), "2020-04-21T16:15:00CEST")$
\item Syntax: a system of rules that describes which data is \textbf{well-formed}\\
 Example: ``a pair of (a pair of two IEEE double precision floating point numbers) and a string encoding of a time stamp''
\item Semantics: system of rules that determines the meaning of well-formed data
\item Knowledge: combination of some data with its syntax and semantics
\end{itemize}
\end{frame}

\begin{frame}\frametitle{Knowledge is Elusive}
Representation of key concepts 
\begin{itemize}
 \item Data: using primitive objects
  \lec{implemented as bits, bytes, strings, records, arrays, \ldots}
 \item Syntax: (context-free) grammars, (context-sensitive) type systems
  \lec{implemeted as inductive data structures}
 \item Semantics: functions for evaluation, interpretation, of well-formed data
  \lec{implemented as recursive algorithms on the syntax}
 \item Knowledge: elusive
  \lec{emerges from applying and interacting with the semantics}
\end{itemize}
\end{frame}

\begin{frame}\frametitle{Semantics as Translation}
\begin{itemize}
\item Knowledge can be captured by a higher layer of syntax
\item Then semantics is translation into syntax
\end{itemize}

\begin{center}
\begin{tabular}{l|l|l}
Data syntax & Semantics function & Knowledge syntax \\
\hline
SPARQL query & evaluation & result set \\
SQL query & evaluation & result table \\
program & compiler & binary code \\
program expression & interpreter & result value \\ 
logical formula & interpretation in a model & mathematical object \\
HTML document & rendering & graphics context
\end{tabular}
\end{center}
\end{frame}

\begin{frame}\frametitle{Heterogeneity of Data and Knowledge}
\begin{itemize}
\item Capturing knowledge is difficult
\item Many different approaches to semantics
 \begin{itemize}
  \item fundamental formal and methodological differences
  \item often captured in different fields, conferences, courses, languages, tools
 \end{itemize}
\item Data formats equally heterogeneous
 \begin{itemize}
 \item ontologies
 \item programs
 \item logical proofs
 \item databases
 \item documents
 \end{itemize}
\end{itemize}
\end{frame}

\begin{frame}\frametitle{Challenges of Heterogeneity}
\begin{blockitems}{Challenges}
\item collaboration across communities
\item translation across languages
\item conversion between data formats
\item interoperability across tools
\end{blockitems}

\begin{blockitems}{Sources of problems}
\item interoperability across formats/tools major source of
 \begin{itemize}
 \item complexity
 \item bugs
 \end{itemize}
\item friction in project team due to differing preferences, expertise
\item difficult choice between languages/tools with competing advantages
\begin{itemize}
 \item reverting choices difficult, costly
 \item maintaining legacy choices increases complexity
\end{itemize}
\end{blockitems}
\end{frame}

\begin{frame}\frametitle{Aspects of Knowledge}
\begin{itemize}
\item Tetrapod model of knowledge
  \lec{active research by our group}
\item classifies approaches to knowledge into five aspects
\end{itemize}

\begin{center}
\begin{tabular}{lll}
Aspect & KRLs (examples) & KPTs (examples) \\
\hline
ontologization & ontology languages (OWL), description logics (ALC) & reasoners, SPARQL engines (Virtuoso) \\
concretization & relational databases (SQL, JSON) & databases (MySQL, MongoDb) \\
computation & programming languages (C) & interpreters, compilers (gcc) \\
deduction & logics (HOL) & theorem provers (Isabelle) \\
narration & document languages (HTML, LaTeX) & editors, viewers
\end{tabular}
\end{center}
\end{frame}

\begin{frame}\frametitle{Relations between the Aspects}
Ontology is distinguished: capture the knowledge that the other four aspects share

\begin{center}
\begin{tikzpicture}[scale=4]
  \node (center) at (0,.15) {Ontologization};
  \node (left) at (.2,-.3) {Computation};
  \node (right) at (.4,0) {Concretization};
  \node (back) at (-.5,0) {Deduction};
  \node (up) at (0,.5) {Narration};

  \draw[very thick] (center) -- (left);
  \draw[very thick] (center) -- (right);
  \draw[very thick] (center) -- (back);
  \draw[very thick] (center) -- (up);
  \draw[dotted] (left) -- (right) -- (back) -- (left);
  \draw[dotted] (up) -- (left);
  \draw[dotted] (up) -- (right);
  \draw[dotted] (up) -- (back);
\end{tikzpicture}
\end{center}
\end{frame}

\begin{frame}\frametitle{Complementary Advantages of the Aspects}
\begin{center}
\footnotesize
\begin{tabular}{|l|llp{2.1cm}l|}\hline
Aspect & objects & \multicolumn{3}{c|}{characteristic} \\
       &         & advantage & joint advantage of the other aspects & application \\\hline
ded. & formal proofs & correctness & ease of use & verification \\
comp. & programs & efficiency & well-definedness & execution\\
concr. & concrete objects & tangibility & abstraction & storage/retrieval\\
narr. & texts & flexibility & formal semantics & human understanding\\\hline
\end{tabular}
\medskip

\begin{tabular}{|l|l|}\hline
Aspect pair & characteristic advantage \\\hline
ded./comp.  & rich meta-theory \\
narr./conc. & simple languages \\\hline
ded./narr.  & theorems and proofs \\
comp./conc. & normalization \\\hline
ded./conc.  & decidable well-definedness \\
comp./narr. & Turing completeness \\\hline
\end{tabular}
\end{center}
\end{frame}

\begin{frame}\frametitle{Structure of the Course}
\begin{blockitems}{Aspect-independent parts}
\item general methods that are shared among the aspects
\item to be discussed as they come up
\end{blockitems}

\begin{blockitems}{Aspects-specific parts}
\item one part (about 2 weeks) for each aspect
\item high-level overview of state of the art
\item focus on comparison/evaluation of the aspect-specific results
\end{blockitems}
\end{frame}

\begin{frame}\frametitle{Structure of the Exercises}
\begin{blockitems}{One major project}
\item representative for a project that a CS graduate might be put in charge of
\item challenging heterogeneous data and knowledge
\item requires integrating/combining different languages, tools
\end{blockitems}
\lec{unique opportunity in this course because knowledge is everywhere}

\begin{blockitems}{Concrete project}
\item develop a univis-style system for a university
\item lots of heterogeneous knowledge
 \begin{itemize}
 \item course and program descriptions
 \item legal texts
 \item websites
 \item grade tables
 \item transcript generation code
 \end{itemize} 
\item build a completely functional system applying the lessons of the course
\end{blockitems}
\end{frame}

\section{Ontological Knowledge}

\begin{frame}\frametitle{Components of an Ontology}
8 main declarations
\begin{itemize}
 \item \textbf{individual} --- concrete objects that exist in the real world, e.g., "Florian Rabe" or "WuV"
 \item \textbf{concept} --- abstract groups of individuals, e.g., "instructor" or "course"
 \item \textbf{relation} --- binary relations between two individuals, e.g., "teaches"
 \item \textbf{properties} --- binary relations between an individuals and a concrete value (a number, a date, etc.), e.g., "has-credits"
 \item \textbf{concept assertions} --- the statement that a particular individual is an instance of a particular concept
 \item \textbf{relation assertions} --- the statement that a particular relation holds about two individuals
 \item \textbf{property assertions} --- the statement that a particular individual has a particular value for a particular property
 \item \textbf{axioms} --- statements about relations between concepts, e.g., "instructor" $\sqsubseteq$ "person"
\end{itemize}
\end{frame}

\begin{frame}\frametitle{Divisions of an Ontology}
\begin{blockitems}{Abstract vs. concrete}
 \item TBox: concepts, relations, properties, axioms
  \lec{everything that does not use individuals}
 \item ABox: individuals and assertions
\end{blockitems}

\begin{blockitems}{Named vs. unnamed}
 \item Signature: individuals, concepts, relations, properties \lec{together called entities or resources}
 \item Theory: assertions, axioms
\end{blockitems}
\end{frame}

\begin{frame}\frametitle{Comparison of Terminology}
\begin{center}
\tiny
\begin{tabular}{l|llll|l}
 Here       & OWL      & Description logics & ER model & UML & semantics via logics\\
\hline
 individual & instance & individual & entity & object, instance & constant\\
 concept    & class    & concept &  entity-type & class & unary predicate\\
 relation   & object property & role & role & association & binary predicate \\
 property   & data property   & (not common) & attribute & field of base type & binary predicate\\
\end{tabular}
\medskip

\begin{tabular}{l|ll}
 domain & individual & concept \\
\hline
type theory, logic & constant, term & type \\
set theory  & element & set \\
database    & row & table \\
philosophy\footnote{as in \url{https://plato.stanford.edu/entries/object/}} & object & property \\
grammar & proper noun & common noun \\
\end{tabular}
\end{center}
\end{frame}

\begin{frame}\frametitle{Ontologies as Sets of Triples}
\begin{center}
\begin{tabular}{l|lll}
Assertion & \multicolumn{3}{c}{Triple} \\
          & Subject & Predicate & Object \\
\hline
concept assertion  & "Florian Rabe" & \texttt{is-a} & "instructor" \\
relation assertion & "Florian Rabe" & "teaches" & "WuV" \\
property assertion & "WuV" & "has credits" & 7.5 \\
\end{tabular}
\medskip

Efficient representation of ontologies using RDF and RDFS standardized special entities.
\end{center}
\end{frame}

\begin{frame}\frametitle{Special Entities}
RDF and RDFS define special entities for use in ontologies:
\begin{itemize}
 \item "rdfs:Resource": concept of which all individuals are an instance and thus of which every concept is a subconcept
 \item "rdf:type": relates an entity to its type:
  \begin{itemize}
   \item an individual to its concept (corresponding to \texttt{is-a} above)
   \item other entities to their special type (see below)
  \end{itemize}
 \item "rdfs:Class": special class for the type of classes
 \item "rdf:Property": special class for the type of properties
 \item "rdfs:subClassOf": a special relation that relates a subconcept to a superconcept
% \item "rdfs:subPropertyOf": a special relation that relates a relation to one that it implies
 \item "rdfs:domain": a special relation that relates a relation to the concepts of its subjects
 \item "rdfs:range": a special relation that relates a relation/property to the concept/type of its objects
\end{itemize}

Goal/effect: capture as many parts as possible as RDF triples.
\end{frame}

\begin{frame}\frametitle{Declarations as Triples using Special Entities}
\begin{center}
\begin{tabular}{l|lll}
Assertion & \multicolumn{3}{c}{Triple} \\
          & Subject & Predicate & Object \\
\hline
individual & individual & "rdf:type" & "rdfs:Resource" \\
concept  & concept & "rdf:type" & "rdf:Class" \\
relation & relation & "rdf:type" & "rdf:Property" \\
property & property & "rdf:type" & "rdf:Property" \\
concept assertion  & individual & "rdf:type" & concept \\
relation assertion & individual & relation & individual \\
property assertion & individual & property & value \\
\hline
\multicolumn{4}{l}{for special forms of axioms}\\
$c\sqsubseteq d$ & $c$ & "rdfs:subClassOf" & $d$ \\
%$r\sqsubseteq s$ & $r$ & "rdfs:subPropertyOf" & s \\
$\dom\,r\Equiv c$ & $r$ & "rdfs:domain" & $c$ \\
$\rng\, r\Equiv c$ & $r$ & "rdfs:range" & $c$ \\
\end{tabular}
\end{center}
\end{frame}

\begin{frame}\frametitle{An Example Ontology Language}
see syntax of BOL in the lecture notes
\end{frame}

\section{Semantics as Translation}

\begin{frame}\frametitle{Example: Syntax of Arithmetic Language}
Syntax: represented as formal grammar

\begin{commgrammar}
\gcomment{Numbers}\\
\gprod{N}{0\bnfalt 1}{literals}\\
\galtprod{N+N}{sum}\\
\galtprod{N*N}{product}\\
\gcomment{Formulas}\\
\gprod{F}{N\doteq N}{equality}\\
\galtprod{N\leq N}{ordering by size}\\
\end{commgrammar}

Implementation as inductive data type
\end{frame}


\begin{frame}\frametitle{Example: Semantics of Arithmetic Language}
Semantics: represented as translation into known language
\medskip

Problem: Need to choose a known language first\\
Here: unary numbers represented as strings

Built-in data (strings and booleans):
\begin{commgrammar}
%\gcomment{Strings}\\
\gprod{S}{\epsilon}{empty}\\
\galtprod{(\texttt{Unicode)}}{characters}\\
%\gcomment{Booleans}\\
\gprod{B}{\cn{true}}{truth}\\
\galtprod{\cn{false}}{falsity}\\
\end{commgrammar}

Built-in operations to work on the data:
\begin{itemize}
\item concatenation of strings $S\bbc \cn{conc}(S,S)$
\item replacing all occurrences of $c$ in $S_1$ with $S_2$ $S\bbc \cn{replace}(S_1,c,S_2)$
\item equality test: $B\bbc S_1==S_2$
\item prefix test: $B\bbc \cn{startsWith}(S_1,S_2)$
\end{itemize}
\end{frame}

\begin{frame}\frametitle{Example: Semantics of Arithmetic Language}
\begin{blockitems}{Represented as function from syntax to semantics}
\item mutually recursive, inductive functions for each non-terminal symbol
\item compositional: recursive call on immediate subterms of argument
\end{blockitems}

For numbers $n$: semantics $\sem{n}$ is a string
\begin{itemize}
\item $\sem{0}=\epsilon$
\item $\sem{1}="|"$
\item $\sem{m+n}=\cn{conc}(\sem{m},\sem{n})$
\item $\sem{m*n}=\cn{replace}(\sem{m},"|",\sem{n})$
\end{itemize}
\medskip

For formulas $f$: semantics $\sem{f}$ is a boolean
\begin{itemize}
\item $\sem{m\doteq n}=\sem{m}==\sem{n}$
\item $\sem{m\leq n}=\cn{startsWith}(\sem{n},\sem{m})$
\end{itemize}
\end{frame}

\begin{frame}\frametitle{Semantics of BOL}
\begin{center}
\begin{tabular}{lll}
Aspect & kind of semantic language & semantic language\\
\hline 
deduction & logic & SFOL \\
concretization & database language & SQL \\
computation & programming language & Scala \\
narration & natural language & English \\
\end{tabular}
\end{center}

see details of each translation in the lecture notes
\end{frame}

\begin{frame}\frametitle{General Definition}
A semantics by translation consists of
\begin{itemize}
 \item syntax: a formal language $l$
 \item semantic language: a formal language $L$
  \glec{different or same aspect as $l$}
 \item semantic prefix: a theory $P$ in $L$
  \glec{formalizes fundamentals that are needed to represent $l$-objects}
 \item interpretation: translates every $l$-theory $T$ to an $L$-theory $P,\sem{T}$
\end{itemize}
\end{frame}

\begin{frame}\frametitle{Common Principles}
Properties shared by all semantics of BOL
\lec{not part of formal definition, but best practices}
\begin{itemize}
 \item $l$-declaration translated to $L$-declaration for the same name
 \item ontologies translated declaration-wise
 \item one inductive function for every kind of complex $l$-expression
  \begin{itemize}
   \item individuals, concepts, relations, properties, formulas
   \item maps $l$-expressions to $L$-expressions
  \end{itemize}
 \item atomic cases (base cases): $l$-identifier translated to $L$-identifier of the same name
  \glec{or something very similar}
 \item complex cases (step cases): compositional
\end{itemize}
\end{frame}

\begin{frame}\frametitle{Compositionality}
Case for operator $*$ in interpretation function compositional iff \\
interpretation of $*(e_1,\ldots,e_n)$ only depends on on the interpretation of the $e_i$

\[\sem{*(e_1,\ldots,e_n)}=\sem{*}(\sem{e_1},\ldots,\sem{e_n})\]
for some function $\sem{*}$
\bigskip

Example: $;$-operator of BOL in translation to FOL
\begin{itemize}
 \item translation: $\sem{R_1 ; R_2}= \exists m:\iota.\sem{R_1}(x,m)\wedge \sem{R_2}(m,y)$
 \item special case of the above via
  \begin{itemize}
  \item $*=;$
  \item $n=2$
  \item $\sem{;}=(p_1,p_2)\mapsto \exists m:\iota.p_1(x,m)\wedge p_2(m,y)$
  \end{itemize}
 \item Indeed, we have $\sem{R_1;R_2}=\sem{;}(\sem{R_1},\sem{R_2})$
\end{itemize}
\end{frame}


\begin{frame}\frametitle{Compositionality (2)}
Translation compositional iff
\begin{itemize}
\item one translation function for each non-terminal
 \glec{all written $\sem{-}$}
\item each defined by one induction on syntax
 \glec{i.e., one case for production}
 \glec{mutually recursive}
\item all cases compositional
\end{itemize}
\bigskip

Substitution theorem: a compositional translation satisfies
\[\sem{E(e_1,\ldots,e_n)}=\sem{E}(\sem{e_1},\ldots,\sem{e_n})\]
for
\begin{itemize}
\item every expression $E(N_1,\ldots,N_n)$ with non-terminals $N_i$
\item some function $\sem{E}$ that only depends on $E$
\end{itemize}
\end{frame}


\begin{frame}\frametitle{Compositionality (3)}
\[\sem{E(e_1,\ldots,e_n)}=\sem{E}(\sem{e_1},\ldots,\sem{e_n})\]
for every expression $E(N_1,\ldots,N_n)$ with non-terminals $N_i$
\bigskip

Now think of
\begin{itemize}
\item variable $x_i$ of type $N_i$ instead of non-terminal $N_i$
\item $E(x_1,\ldots,x_n)$ as expression with free variables $x_i$ of type $N_i$
\item expressions $e$ derived from $N$ as expressions of type $N$
\item $E(e_1,\ldots,e_n)$ as result of substituting $e_i$ for $x_i$
\item $\sem{E}(x_1,\ldots,x_n)$ as (semantic) expression with free variables $x_i$
\end{itemize}

Then both sides of equations act on $E(x_1,\ldots,x_n)$:
\begin{itemize}
\item left side yields $\sem{E(e_1,\ldots,e_n)}$ by
\begin{itemize}
\item first substitution $e_i$ for $x_i$
\item then semantics $\sem{-}$ of the whole
\end{itemize}
\item right side yields $\sem{E}(\sem{e_1},\ldots,\sem{e_n})$ by
\begin{itemize}
\item first semantics $\sem{-}$ of all parts
\item then substitution $\sem{e_i}$ for $x_i$
\end{itemize}
\end{itemize}
\lec{semantics commutes with substitution}
\end{frame}

\begin{frame}\frametitle{Non-Compositionality}
\begin{blockitems}{Examples}
 \item deduction: cut elimination, translation from natural deduction to Hilbert calculus
 \item computation: optimizing compiler, e.g., loop unrolling
 \item concretization: query optimization, e.g., turning a WHERE of a join into a join of WHEREs,
 \item narration: ambiguous words are translated based on context
\end{blockitems}

\begin{blockitems}{Typical sources}
 \item subcases in a case of translation function
  \begin{itemize}
  \item based on inspecting the arguments, e.g., subinduction
  \item based on context
  \end{itemize}
 \item custom-built semantic prefix
\end{blockitems}
\end{frame}

\section{Type Systems}

\begin{frame}\frametitle{Breakout Question}
Is this an improvement over BOL?
\begin{commgrammar}
\gcomment{Declarations}\\
\gprod{D}{\kw{individual}\; \ID: C}{typed atomic individual}\\
\galtprod{\kw{concept}\; \ID}{atomic concept}\\
\galtprod{\kw{relation}\; \ID\sq C\times C}{typed atomic relation}\\
\galtprod{\kw{property}\; \ID\sq C\times T}{typed atomic property}\\
\end{commgrammar}
\glec{rest as before}
\end{frame}

\begin{frame}\frametitle{Actually, when is a language an improvement?}
Criteria:
 \lec{orthogonal, often mutually exclusive}
\begin{itemize}
\item syntax design trade-off
 \begin{itemize}
  \item expressivity: easy to express knowledge
    \glec{e.g., big grammar, extra production for every user need}
  \item simplicity: easy to implement/interpret
    \glec{e.g., few, carefully chosen productions}
 \end{itemize}
\item semantics: specify, implement, document
\item intended users
 \begin{itemize}
  \item skill level
  \item prior experience with related languages
  \item amount of training needed
 \end{itemize}
\item long-term plans: re-answer the above question but now
 \begin{itemize}
  \item maintainability: syntax was changed, everything to be redone
  \item scalability: expressed knowledge content has reached huge sizes
 \end{itemize}
\end{itemize}
\end{frame}

\begin{frame}\frametitle{Church vs. Curry Typing}
\begin{center}
\footnotesize
\begin{tabular}{l|ll}
& intrinsic & extrinsic \\
\hline
$\lambda$-calculus by & Church & Curry \\
type is & carried by object & given by environment \\
typing is a & function objects $\to$ types & relation objects $\times$ types \\
objects have & unique type & any number of types \\
types interpreted as & disjoint sets & unary predicates \\
\hline
type given by & part of declaration & additional axiom \\
 \tb example               &  \kw{individual} "WuV":"course"  & \kw{individual} "Wuv",\\
                           &                                  & "WuV" \texttt{is-a} "course"\\
\hline
examples   & SFOL, SQL & OWL, Scala, English \\
           & most logics, functional PLs & ontology, OO, \\
           &                             & natural languages \\
           & many type theories & set theories
\end{tabular}
\end{center}
\end{frame}

\begin{frame}\frametitle{Type Checking}
\begin{center}
\footnotesize
\begin{tabular}{l|ll}
& intrinsic & extrinsic \\
\hline
type is & carried by object & given by environment \\
typing is a & function objects $\to$ types & relation objects $\times$ types \\
objects have & unique type & any number of types \\
\hline
type given by & part of declaration & additional axiom \\
 \tb example               &  \kw{individual} "WuV":"course"  & \kw{individual} "Wuv",\\
                           &                                  & "WuV" \texttt{is-a} "course"\\
\hline
type inference for $x$ & uniquely infer $A$ from $x$ & find minimal $A$ with $x:A$ \\
type checking & inferred=expected & prove $x:A$ \\
subtyping $A<:B$ & cast from $A$ to $B$ & $x:A$ implies $x:B$ \\
typing decidable & yes unless too expressive & no unless restricted \\
typing errors & static (compile-time) & dynamic (run-time)\\
\hline
advantages & easy & flexible \\
           & unique type inference & allows subtyping \\
\end{tabular}
\end{center}
\end{frame}

\begin{frame}\frametitle{Curry Typing in BOL}
\begin{center}
\footnotesize
\begin{tabular}{l|lll}
language  & objects & types & typing relation\\
\hline
Syntax & individuals & concepts & $i$ \texttt{is-a} $c$ \\
\hline
Semantics in &&&\\
FOL & type $\iota$  & predicates $c\sq\iota$ & $c(i)$ true\\
SQL & table Individuals & tables containing ids & id of i in table $c$ \\
Scala & String & hash sets of strings & $c$.contains($i$) \\
English & proper nouns & common nouns & "$i$ is a $c$" is true
\end{tabular}
\end{center}
\end{frame}

\begin{frame}\frametitle{Subtyping}
Subtyping works best with Curry Typing
\begin{itemize}
 \item explicit subtyping as in $\N<:\Z$
 \item comprehension/refinement as in $\{x:\N|x\neq 0\}$
 \item operations like union and intersection on types
 \item inheritance between classes, in which case subclass = subtype
 \item anonymous record types as in $\{x:\N,y:\Z\}<:\{x:\N\}$
\end{itemize}
\end{frame}

\begin{frame}\frametitle{A General Definition of a Type System}
A \textbf{type system} consists of
\begin{itemize}
 \item a collection, whose elements are called \textbf{objects},
 \item a collection, whose elements are called \textbf{intrinsic types},
 \item a function assigning to every object $x$ its \textbf{intrinsic type} $I$, in which case we write $x:I$,
 \item for some intrinsic types $I$
  \begin{itemize}
   \item an intrinsic type $E_I$
   \item a relation $\in_I$ between objects with intrinsic types $I$ and $E_I$, called the \textbf{extrinsic typing} relation for $I$.
  \end{itemize}
\end{itemize}
\end{frame}

\begin{frame}\frametitle{Examples}
\begin{center}
\begin{tabular}{l|lll}
System & intrinsic types & $E_I$ & $\in_I$ \\
\hline
pure Church & one per type & none & none \\
pure Curry & objects $O$, types $T$ & $E_O=T$ & $\in_O=:$ \\
%\hline
FOL & one per type & none & none \\
Scala & $AnyRef$, $Class$ & $E_{Any}=Class$ & $\in_{Any}=\mathtt{isInstanceOf}$\\ 
BOL & $Ind$, $Conc$ & $E_{Ind}=Conc$ & $\in_{Ind}=\mathtt{is-a}$\\
set theory & $Set$, $Prop$ & $E_{Set}=Set$ & $\in_{Set}=\in$ \\
\end{tabular}
\end{center}
\end{frame}

\begin{frame}\frametitle{Breakout Question}
What do the following have in common?
\begin{itemize}
\item Java class
\item SQL schema for a table
\item logical theory (e.g., Monoid)
\end{itemize}
\onslide<2>{all are (essentially) abstract data types}
\end{frame}

\begin{frame}[fragile]\frametitle{Abstract Data Types: Motivation}
Recall subject-centered representation of assertion triples:

\begin{lstlisting}
individual "FlorianRabe"
  is-a "instructor" "male"
  "teach" "WuV" "KRMT"
  "age" 40
  "office" "11.137"
\end{lstlisting}

Can we use types to force certain assertions to occur together?
\begin{itemize}
\item Every instructor should teach a list of courses.
\item Every instructor should have an office.
\end{itemize}
\end{frame}

\begin{frame}[fragile]\frametitle{Abstract Data Types: Motivation}
Inspires \textbf{subject-centered types}, e.g.,

\begin{lstlisting}
concept instructor
  teach course$^*$
  age: int
  office: string

individual "FlorianRabe": "instructor"
  is-a "male"
  teach "WuV" "KRMT"
  age 40
  office "11.137"
\end{lstlisting}

Incidental benefits:
\begin{itemize}
\item no need to declare relations/properties separately
\item reuse relation/property names \\ distinguish via qualified names: \lstinline|instructor.age|
\end{itemize}
\end{frame}

\begin{frame}[fragile]\frametitle{Abstract Data Types: Motivation}
Natural next step: inheritance

\begin{lstlisting}
concept person
  age: int
  
concept male <: person

concept instructor <: person
  teach course$^*$
  office: string

individual "FlorianRabe": "instructor" $\sqcap$ "male"
  "teach" "WuV" "KRMT"
  "age" 40
  "office" "11.137"
\end{lstlisting}

\lec{our language quickly gets a very different flavor}
\end{frame}

\begin{frame}\frametitle{Abstract Data Types: Examples}
Prevalence of abstract data types:

\begin{center}
\begin{tabular}{l|ll}
aspect & language & abstract data type \\
\hline
ontologization & UML & class \\
concretization & SQL & table schema \\
computation & Scala & class, interface \\
deduction & various & theory, specification, module, locale \\
narration & various & emergent feature
\end{tabular}
\end{center}

\lec{same idea, but may look very different across languages}
\end{frame}

\begin{frame}\frametitle{Abstract vs. Concrete Types}
\textbf{Concrete} type: values are
\begin{itemize}
\item given by their internal form,
\item defined along with the type, typically built from already-known pieces.
\end{itemize}
\lec{examples: products, inductive data types}

\textbf{Abstract} type: values are
\begin{itemize}
\item given by their externally visible properties,
\item defined in any environment that understands the type definition.
\end{itemize}
\lec{main example: abstract data types}
\end{frame}

\begin{frame}\frametitle{Abstract Data Types: Examples}
\begin{center}
\begin{tabular}{l|ll}
aspect & type & values \\
\hline
computation & abstract class & instances of implementing classes \\
concretization & table schema & table rows \\
deduction & theory & models
\end{tabular}
\end{center}

Values depend on the environment in which the type is used:
\begin{itemize}
\item class defined in one specification language (e.g., UML), \\
 implementations in programing languages Java, Scala, etc.
 \lec{available values may depend on run-time state}
\item theory defined in logic,\\
 models defined in set theories, type theories, programming languages
 \lec{available values may depend on philosophical position}
\end{itemize}
\end{frame}

\begin{frame}\frametitle{Abstract Data Types: Definition}
Given some type system, an \textbf{abstract data type} (ADT) is
\begin{itemize}
\item a \textbf{flat} type
  \[\{c_1:T_1[=t_1],\ldots,c_n:T_n[=t_n]\}\]
  where
  \begin{itemize}
  \item $c_i$ are distinct names
  \item $T_i$ are types
  \item $t_i$ are optional definitions; if given, $t_i:T_i$ required
  \end{itemize}
\item or a \textbf{mixin} type
  \[A_1*\ldots*A_n\]
  for ADTs $A_i$.
\end{itemize}

Languages may or may not make ADTs additional types of the type system
\end{frame}

\begin{frame}[fragile]\frametitle{Abstract Data Types: Class Definitions}
A class definition in OO:

\begin{lstlisting}
abstract class $a$ extends $a_1$ with $\ldots$ with $a_m$ {
  $c_1$: $T_1$
  $\vdots$
  $c_n$: $T_n$
}
\end{lstlisting}

Corresponding ADT definition:
\[a = a_1*\ldots*a_m*\{c_1:T_1,\ldots,c_n:T_n\}\]
\medskip

The usual terminology:
\begin{itemize}
\item $a$ \textbf{inherits} from $a_i$
\item $a_i$ are \textbf{super}-X or \textbf{parent}-X of $a$ where $X$ is whatever the language calls its ADTs (e.g., X=class)
\end{itemize}
\end{frame}

\begin{frame}\frametitle{Abstract Data Types: Flattening}
The \textbf{flattening} $\flt{A}$ of an ADT $A$ is
\begin{itemize}
 \item if $A$ is flat: $\flt{A}=A$
 \item $\flt{(A_1*\ldots*A_n)}$ is union of all $\flt{A_i}$\\
  where duplicate field names are handled as follows
  \begin{itemize}
   \item same name, same type, same or omitted definition: merge
    \glec{details may be much more difficult}
   \item otherwise: ill-formed
  \end{itemize}
\end{itemize}
\end{frame}

\begin{frame}\frametitle{Abstract Data Types: Subtleties}
We gloss over several major issues:
\begin{itemize}
\item How exactly do we merge duplicate field names? Does it always work?
 \lec{implement abstract methods, override, overload} 
\item Is recursion allowed, i.e., can I define an ADT $a=A$ where $a$ occurs in $A$?
 \lec{common in OO-languages: use $a$ in the types of its fields}
\item What about ADTs with type arguments?
 \lec{e.g., generics in Java, square-brackets in Scala}
\item Is mutual recursion between fields in a flat type allowed?
 \lec{common in OO-languages}
\item Is * commutative? What about dependencies between fields?
\end{itemize}
\lec{no unique answers}
\lec{incarnations of ADTs subtly different across languages}
\end{frame}

\section{Context-Sensitive Syntax}

\begin{frame}\frametitle{Definition}
A \textbf{language system} consists of
\begin{itemize}
 \item context-free syntax
 \item distinguished non-terminal symbol $\ThySym$ \glec{words called \textbf{vocabularies}}
 \item some distinguished non-terminal symbols $\ExpSym$ \glec{words called $\ExpSym$-\textbf{expressions}}
 \item unary predicate $\wft{\Theta}$ on vocabularies $\Theta$ \glec{well-formed vocabulary $\Theta$}
 \item unary predicates $\wff{\Theta}{\ExpSym}{E}$ \glec{well-formed $\ExpSym$-expressions $E$}
\end{itemize}
\end{frame}

\begin{frame}\frametitle{Typical Structure}
Vocabularies
\begin{itemize}
\item lists of declarations
\end{itemize}

Declarations
\begin{itemize}
\item named
\item at least one for each expression kind
\item may contain other expressions \glec{e.g., type, definition}
\item may contain nested declarations \glec{e.g., fields in an ADT}
\end{itemize}

Expressions
\begin{itemize}
\item inductive data type
\item relative to vocabulary \glec{names occur as base cases}
\item formulas as special case
\end{itemize}
\end{frame}

\begin{frame}\frametitle{Vocabularies and Expressions}
\begin{center}
\footnotesize
\begin{tabular}{l|ll}
Aspect & vocabulary $\Theta$ & expression kinds $\ExpSym$ \\
\hline
Ontologization  & ontology & individual, concept, relation, property, formula \\
Concretization & database schema & cell, row, table, formula \\
Computation & program & term, type, object, class, \ldots \\
Logic & signature, theory & term, type, formula, \ldots \\
Narration & dictionary & phrases, sentences, texts \\
\end{tabular}
\end{center}
\end{frame}

\begin{frame}\frametitle{Examples}
See notes made during the lecture for examples
\end{frame}

\section{Concrete Knowledge}

\begin{frame}\frametitle{Motivation}
\begin{blockitems}{Main ideas}
\item Ontology abstractly describes concepts and relations
\item Tool maintains concrete data set
\item Focus on efficiently
  \begin{itemize}
  \item identifying (i.e., assign names)
  \item representing
  \item processing
  \item querying
  \end{itemize}
  large sets of concrete data
\end{blockitems}

\begin{blockitems}{Recall: TBox-ABox distinction}
  \item TBox: general parts, abstract, fixed
   \lec{main challenge: correct modeling of domain}
  \item ABox: concrete individuals and assertions about them, growing
   \lec{main challenge: aggregate them all}
\end{blockitems}
\end{frame}

\begin{frame}\frametitle{Concrete Data}
\begin{blockitems}{Concrete is}
\item Base values: integers, strings, booleans, etc.
\item Collections: sets, multisets, lists (always finite)
\item Aggregations: tuples, records (always finite)
\item User-defined concrete data: enumerations, inductive types
\item Advanced objects: finite maps, graphs, etc.
\end{blockitems}

\begin{blockitems}{Concrete is not}
\item Free symbols to be interpreted by a model
 \lec{exception: foreign function interfaces}
\item Variables (free or bound)
 \lec{$\lambda$-abstraction, quantification}
\item Symbolic expressions
 \lec{formulas, algorithms}
 Exceptions:
  \begin{itemize}
  \item expressions of inductive type
  \item application of built-in functions
  \item queries that return concrete data
  \end{itemize}
\end{blockitems}
\end{frame}

\begin{frame}\frametitle{Breakout question}
What is the difference between
\begin{itemize}
\item an OWL ontology
\item an SQL database
\end{itemize}
\end{frame}

\begin{frame}\frametitle{Two Approaches}
\begin{blockitems}{Based on \emph{untyped} (Curry-typed) ontology languages}
\item Representation based on \emph{knowledge graph}
\item Ontology written in BOL-like language
\item Data maintained as \emph{set of triples}
  \glec{tool = triple store}
\item Typical language/tool design
 \begin{itemize}
 \item ontology and query language \emph{separate}
  \glec{e.g., OWL, SPARQL}
 \item triple store and query engine integrated
  \glec{e.g., Virtuoso tool}
 \end{itemize}
\end{blockitems}

\begin{blockitems}{Based on \emph{typed} (Church-typed) ontology languages}
\item Representation based on \emph{abstract data types}
\item Ontology written as database schema
\item Data maintained as \emph{tables}
  \glec{tool = (relational) database}
\item Typical language/tool design
 \begin{itemize}
 \item ontology and query language \emph{integrated}
  \glec{e.g., SQL}
 \item table store and query engine integrated
  \glec{e.g., SQLite tool}
 \end{itemize}
\end{blockitems}
\end{frame}

\begin{frame}\frametitle{Evolution of Approaches}
\begin{blockitems}{Our usage is non-standard}
 \item Common
  \begin{itemize}
  \item ontologies = untyped approach, OWL, triples,  SPARQL
  \item databases = typed approach, tables, SQL
  \end{itemize}
 \item Our understanding: two approaches evolved from same idea
	\begin{itemize}
	\item triple store = untyped database
	\item SQL schema = typed ontology
	\end{itemize}
\end{blockitems}

\begin{blockitems}{Evolution}
\item Typed-untyped distinction minor technical difference
\item Optimization of respective advantages causes speciation
\item Today segregation into different
 \begin{itemize}
 \item jargons
 \item languages, tools
 \item communities, conferences
 \item courses
 \end{itemize}
\end{blockitems}
\end{frame}

\begin{frame}\frametitle{Curry-typed concrete data}
\begin{blockitems}{Central data structure = knowledge graph}
\item nodes = individuals $i$
 \begin{itemize}
 \item identifier
 \item sets of concepts of $i$
 \item key-value sets of properties of $i$
 \end{itemize}
\item edges = relation assertions
 \begin{itemize}
 \item from subject to object
 \item labeled with name of relation
 \end{itemize}
\end{blockitems}

\begin{blockitems}{Processing strengths}
\item store: as triple set
\item edit: Protege-style or graph-based
\item visualize: as graph
  \glec{different colors for concepts, relations}
\item query: match, traverse graph structure
\item untyped data simplifies integration, migration
\end{blockitems}
\end{frame}

\begin{frame}\frametitle{Church-typed concrete data}
\begin{blockitems}{Central data structure = relational database}
\item tables = abstract data type
\item rows = objects of that type
\item columns = fields of ADT
\item cells = values of fields
\end{blockitems}

\begin{blockitems}{Processing strengths}
\item store: as CSV text files, or similar
\item edit: SQL commands or table editors
\item visualize: as table view
\item query: relational algebra
\item typed data simplifies selecting, sorting, aggregating
\end{blockitems}
\end{frame}

\begin{frame}\frametitle{Identifiers}
\begin{blockitems}{Curry-Typed Knowledge graph}
\item concept, relation, property names given in TBox
\item individual names attached to nodes
\end{blockitems}

\begin{blockitems}{Church-Typed Database}
\item table, column names given in schema
\item row identified by distinguished column (= key) \\
options
 \begin{itemize}
 \item preexistent characteristic column
 \item added upon insertion
  \begin{itemize}
  \item UUID string
  \item incremental integers
  \item concatenation of characteristic list of columns
  \end{itemize} 
 \end{itemize}
\item column/row identifiers formed by qualifying with table name
\end{blockitems}
\end{frame}

\begin{frame}\frametitle{Axioms}
\begin{blockitems}{Curry-Typed Knowledge Graph}
\item traditionally very expressive axioms
\item yields inferred assertions
\item triple store must do consequence closure to return correct query results
\item not all axioms supported by every triple store
\end{blockitems}

\begin{blockitems}{Church-Typed Database}
\item typically no axioms
\item instead consistency constraints, triggers
\item allows limited support for axioms without calling it that way
\item stronger need for users to program the consequence closure manually
\end{blockitems}
\end{frame}

\begin{frame}\frametitle{Breakout question}
When using typed concrete data,\\
how to fully realize abstract data types
\begin{itemize}
\item nesting: ADTs occurring as field types
\item inheritance between ADTs
\item mixins
\end{itemize}
\end{frame}

\begin{frame}\frametitle{ADTs in Typed Concrete Data}
\begin{blockitems}{Nesting: field $a:A$ in ADT $B$}
\item field types must be base types, $a:A$ not allowed
\item allow $ID$ as additional base type
\item use field $a:ID$ in table $B$
\item store value of $b$ in table $A$
\end{blockitems}

\begin{blockitems}{Inheritance: $B$ inherits from $A$}
\item add field $parent_A$ to table $B$
\item store values of inherited fields of $B$ in table $A$
\end{blockitems}
\lec{general principle: all objects of type $A$ stored in same table}

\begin{blockitems}{Mixin: $A*B$}
\item essentially join of tables $A$ and $B$ on common fields
\item some subtleties depending on ADT flattening
\end{blockitems}
\end{frame}

\begin{frame}\frametitle{Open/Closed World}
\begin{itemize}
\item Question: is the data complete?
 \begin{itemize}
 \item closed world: yes
 \item open world: not necessarily
 \end{itemize}
\item Dimensions of openness
 \begin{itemize}
  \item existence of individual objects
  \item assertions about them
 \end{itemize}
\item Sources of openness
  \begin{itemize}
  \item more exists but has not yet been added
  \item more could be created later
  \end{itemize}
\item Orthogonal to typed/untyped distinction, but in practice
 \begin{itemize}
 \item knowledge graphs use open world
 \item databases use closed world
 \end{itemize}
\end{itemize}
\lec{Open world is natural state, closing adds knowledge}
\end{frame}

\begin{frame}\frametitle{Closing the World}
\begin{blockitems}{Derivable consequences}
 \item induction: prove universal property by proving for each object
 \item negation by failure: atomic property false if not provable
 \item term-generation constraint: only nameable objects exist
\end{blockitems}

\begin{blockitems}{Enabled operations}
 \item universal set: all objects
 \item complement of concept/type
 \item defaults: assume default value for property if not otherwise asserted
\end{blockitems}

\begin{blockitems}{Monotonicity problem}
 \item monotone operation: bigger world = more results
 \item examples: union, intersection, $\exists R.C$, join, IN conditions
 \item counter-examples: complement, $\forall R.C$, NOT IN conditions
\end{blockitems}
\lec{technically, non-monotone operations in open world dubious}
\end{frame}

\part{Primitive Types and Encoding Data}

\section{Motivation}

\begin{frame}\frametitle{Data Interoperability}
\begin{blockitems}{Situation}
 \item languages systems focus on different aspects
  \lec{frequent need to exchange data}
 \item generally, lots of aspect/language-specific objects
  \lec{proofs, programs, tables, sentences}
 \item but same/similar \emph{primitive} data types used across systems
  \lec{should be easy to exchange}
 \end{blockitems}
 
\begin{blockitems}{Problem}
 \item crossing system barriers usually require interchange language
  \lec{serialize as string and reparse}
 \item interchange languages typically untyped
  \lec{XML, JSON, YAML, \ldots}
\end{blockitems}

\begin{blockitems}{Solution}
 \item standardize primitive data types
 \item standardize encoding in interchange languages
\end{blockitems}
\end{frame}

\begin{frame}\frametitle{Primitive vs. Declared}
\begin{blockitems}{Primitive Types}
 \item built into the language
 \item assumed to exist a priori \lec{fundamentals of nature}
 \item fixed semantics (usually interpreted by identity function)
 \end{blockitems}
 
\begin{blockitems}{Triple Structure: 3 kinds of named objects}
 \item the type \glec{eg: 'int'}
 \item values of the type \glec{eg: 0, 1, -1, \ldots}
 \item operations on type \glec{eg: addition, multiplication, \ldots}
\end{blockitems}

\begin{center}
\begin{tabular}{l|ll}
& primitive & declared \\
\hline
introduced by & language designer & user \\
introduced in & grammar & vocabulary $V$ \\
visible in & all vocabularies & $V$ only \\
semantics given & explicitly & implicitly \\
\tb\ldots by & translation function & axioms \\
\end{tabular}
\end{center}
\end{frame}

\begin{frame}\frametitle{Examples}
\begin{blockitems}{Typical primitive types}
 \item natural numbers (= $\N$)
 \item arbitrary precision integers (= $\Z$)
 \item fixed precision integers (32 bit, 64 bit, \ldots)
 \item floating point (float, double, \ldots)
 \item Booleans
 \item characters (ASCII, Unicode)
 \item strings
\end{blockitems}

Observation:
\begin{itemize}
\item essentially the same in every language
 \lec{including whatever language used for semantics}
\item semantics by translation trivial
\end{itemize}
\end{frame}

\begin{frame}\frametitle{Quasi-Primitive = Declared in standard library}
\begin{blockitems}{Standard library}
 \item present in every language
  \glec{assumed empty vocabulary by default}
 \item one fixed vocabulary
  \begin{itemize}
  \item implicitly included into every other vocabulary
  \item implicitly fixed by any translation between vocabularies
  \end{itemize}
 \item objects technically declared
 \item but practically part of primitive objects
\end{blockitems}

\begin{blockitems}{Examples}
\item sufficiently expressive languages
 \begin{itemize}
 \item push many primitive objects to standard library \glec{never all}
 \item simplifies language, especially when defining operations
 \end{itemize}
 \lec{strings in C, BigInteger in Java, inductive type for $\N$}
\item inexpressive languages
\begin{itemize}
\item many primitives \lec{SQL, spreadsheet software}
\item few (quasi)-primitives \lec{few operations available in OWL}
\end{itemize}
\end{blockitems}
\end{frame}

\begin{frame}\frametitle{Treatment in this Course}
\begin{blockitems}{BOL syntax and semantics so far}
\item primitive objects omitted in syntax
\item assumed reasonable collection available
\item assumed same (quasi-)primitive objects in semantic languages
 \lec{irrelevant if interpreting primitive objects as primitive or quasi-primitive}
\end{blockitems}
\lec{largely justified by practical languages}

\begin{blockitems}{But what exactly is the standard?}
\item will present possible solution
\item uses special ontology language just for specifying primitive objects
  \begin{itemize}
   \item name
   \item type
   \item semantics
    \glec{typically narrative; alternatively deductive, computational}
  \end{itemize}
\item current research, not standard practice
\end{blockitems}
\end{frame}

\begin{frame}\frametitle{Encoding Primitive Types}
\begin{blockitems}{Problem}
 \item quickly encounter primitive types not supported by common languages
 \item need to encode them using existing types
  \lec{typically as strings, ints, or prodcuts/lists thereof}
\end{blockitems}

\begin{blockitems}{Examples}
\item date, time, color, location on earth
\item graph, function
\item picture, audio, video
\item physical quantities ($1m$, $1in$, etc.)
\item gene, person
\end{blockitems}

\begin{center}
Breakout questions: What primitive types do we need for univis?
\end{center}
\end{frame}

\begin{frame}\frametitle{Failures of Encodings}
\begin{blockitems}{Y2K bug}
\item date encoded as tuple of integers, using $2$ digits for year
\item needed fixing in year 2000
\item estimated $\$300$ billion spent to change software
\item possible repeat: in 2038, number of seconds since 1970-01-01 (used by Unix to encode time as integer) overflows 32-bit integers
\end{blockitems}

\begin{blockitems}{Genes in Excel}
 \item 2016 study found errors in 20\% of spreadsheets accompanying genomics journal papers
 \item gene names encoded as strings but auto-converted to other types by Excel
 \begin{itemize}
 \item "SEPT2" (Septin 2) converted to September 02
 \item REKIN identifiers, e.g., "2310009E13", converted to float $2.31E+1$
 \end{itemize}
 \glec{\url{https://genomebiology.biomedcentral.com/articles/10.1186/s13059-016-1044-7}}
\end{blockitems}
\end{frame}

\begin{frame}\frametitle{Failures of Encodings (2)}
\begin{blockitems}{Mars Climate Orbiter}
\item two components exchanged physical quantity
\item specification required encoding as number using unit Newton seconds
\item one component used wrong encoding (with pound seconds as unit)
\item led to false trajectory and loss of $\$300$ million device
\end{blockitems}

\begin{blockitems}{Shellshock}
\item bash allowed gaining root access from 1998 to 2014
\item function definitions were encoded as source code
\item not decoded at all; instead, code simply run (as root)
\item allowed appending "; ..." to function definitions
\end{blockitems}
\lec{SQL injection similar: complex data encoded as string, no decoding}

\end{frame}

\begin{frame}\frametitle{Research Goal for Aspect-Independent Data in Tetrapod}
\begin{blockitems}{Standardization of Common Data Types}
 \item Ontology language optimized for declaring types, values, operations
 \glec{semantics must exist but can be extra-linguistic}
 \item Vocabulary declaring such objects
 \glec{should be standardized, modular, extensible}
\end{blockitems}

\begin{blockitems}{Standardization of Codecs}
\item Fixed small set of primitive objects
 \glec{should be (quasi-)primitive in every language}
 \glec{not too expressive, possibly untyped}
\item Standard codecs for translating common types to interchange languages
\end{blockitems}

\begin{blockitems}{Codec for type $A$ and int. lang. $L$}
\item coding function $A$-values $\to$ $L$-objects
\item partial decoding function $L$-objects $\to$ $A$-values
\item inverse to each other \glec{in some sense}
\end{blockitems}
\end{frame}

\begin{frame}\frametitle{Overview}
Next steps
\begin{enumerate}
\item Data types
\item Data interchange languages
\item Codecs
\end{enumerate}
\end{frame}

\section{Data Types}

\begin{frame}{Breakout Question}
What types do we need?
\end{frame}

\begin{frame}\frametitle{Atomic Data Types: basic}
\begin{blockitems}{typical in IT systems}
 \item fixed precision integers (32 bit, 64 bit, \ldots)
 \item IEEE float, double
 \item Booleans
 \item Unicode characters
 \item strings \glec{could be list of characters but usually bad idea}
\end{blockitems}

\begin{blockitems}{typical in math}
 \item natural numbers (= $\N$)
 \item arbitrary precision integers (= $\Z$)
 \item rational, real, complex numbers
 \item graphs, trees
\end{blockitems}
\lec{clear: language must be modular, extensible}
\end{frame}

\begin{frame}\frametitle{Atomic Data Types: advanced}

\begin{blockitems}{general purpose}
 \item date, time, color, location on earth
 \item picture, audio, video
\end{blockitems}

\begin{blockitems}{domain-specific}
 \item physical quantities ($1m$, $1in$, etc.)
 \item gene, person
 \item semester, course id, \ldots
\end{blockitems}

\lec{clear: language must be modular, extensible}
\end{frame}

\begin{frame}\frametitle{Complex Data Types}
\begin{itemize}
 \item relatively easy if all primitive types atomic
  \lec{int, string, etc.}
 \item but need to allow for complex types
\end{itemize}

Two kinds
\begin{itemize}
\item type operators: take \emph{only type arguments}, return types
 \begin{itemize}
 \item type operator $\times$
 \item takes two types $A,B$
 \item returns type $A\times B$
 \end{itemize}
\item dependent types: take \emph{also data arguments}, return types
 \begin{itemize}
 \item dependent type operator $vector$
 \item takes natural number $n$, type $A$
 \item returns type $A^n$ of $n$-tuples over $A$
 \end{itemize}
\end{itemize}
\lec{dependent types much more complicated, less uniformly used}
\lec{harder to starndardize}
\end{frame}

\begin{frame}\frametitle{Collection Data Types}
\begin{blockitems}{Homogeneous Collection Types}
 \item sets
 \item multisets (= bags)
 \item lists
 \lec{all unary type operators, e.g. $list\;A$ is type of lists over $A$}
 \item fixed-length lists (= Cartesian power, vector $n$-tuple)
  \glec{dependent type operator}
\end{blockitems}

\begin{blockitems}{Heterogeneous Collection Types}
 \item lists
 \item fixed-length lists (= Cartesian power, $n$-tuple)
 \item sets
 \item multisets (= bags)
 \lec{all atomic types, e.g., $list$ is type of lists over any objects}
\end{blockitems}
\end{frame}

\begin{frame}\frametitle{Aggregation Data Types}
\begin{blockitems}{Products}
 \item Cartesian product of some types $A\times B$ \\
 values are pairs $(x,y)$ 
 \glec{numbered projections $_1$, $_2$ --- order relevant}
 \item labeled Cartesian product (= record) $\{a: A, b: B\}$ \\
 values are records $\{a=x, b=y\}$
  \glec{named projections $a$, $b$ --- order irrelevant}
\end{blockitems}

\begin{blockitems}{Disjoint Unions}
 \item disjoint union of some types $A\uplus B$\\
  values are $inj_1(x)$, $inj_2(y)$
  \glec{numbered injections $_1$, $_2$ --- order relevant}
 \item labeled disjoint union $a(A)|b(B)$ \\
  values are constructor applications $a(x)$, $b(y)$
  \glec{named injections $a$, $b$ --- order irrelevant}
\end{blockitems}

\glec{labeled disjoint unions uncommon}
\glec{but recursive labeled disjoint union = inductive data type}
\end{frame}

\begin{frame}\frametitle{Subtyping}
\begin{itemize}
 \item relatively easy if all data types disjoint
 \item better with subtyping
 \lec{open problem how to do it nicely}
\end{itemize}

\begin{blockitems}{Subtyping Atomic Types}
 \item $\N <: \Z$
 \item ASCII $<:$ Unicode
\end{blockitems}

\begin{blockitems}{Subtyping Complex Types}
 \item covariance subtyping (= vertical subtyping)
 \glec{same for disjoint unions}
  \[A <: A' \impl list\,A <: list\, A'\]
  \[A_i <: A_i' \impl \{\ldots, a_i:A_i,\ldots\} <: \{\ldots, a_i:A'_i,\ldots\}\]
 \item structural subtyping (= horizontal subtyping)
  \[\{a:A,b:B\} :> \{a:A,b:B,c:C\}\]
  \[a(A)|b(B) <: a(A)|b(B)|c(C)\]
\end{blockitems}
\end{frame}

\section{Data Representation Languages}

\begin{frame}\frametitle{Overview}
\begin{blockitems}{General Properties}
 \item general purpose or domain-specific
 \item typed or untyped
  \lec{typical: Church-typed but no type operators, quasi untyped}
 \item text or binary serialization
 \item libraries for many programming languages
  \begin{itemize}
  \item data structures
  \item serialization (data structure to string)
  \item parsing (string to data structure, partial)
  \end{itemize}
\end{blockitems}

\begin{blockitems}{Candidates}
 \item XML: standard on the web, notoriously verbose
 \item JSON: JavaScript objects, more human-friendly text syntax
  \lec{older than XML, probably better choice than XML in retrospect}
 \item YAML: line/indentation-based
\end{blockitems}
\end{frame}

\begin{frame}{Breakout Question}
What is the difference between JSON, YAML, XML?
\end{frame}

\begin{frame}\frametitle{Typical Data Representation Languages}
XML, JSON, YAML essentially the same
 \lec{except for concrete syntax}

\begin{blockitems}{Atomic Types}
 \item integer, float, boolean, string
 \item need to read fine-print on precision
\end{blockitems}
 
\begin{blockitems}{(Not Very) Complex Types}
 \item heterogeneous lists
  \glec{a single type for all lists}
 \item records
  \glec{a single type for all records}
\end{blockitems}
\end{frame}

\begin{frame}\frametitle{Example: JSON}
JSON:
\[\mathll{
 \{\\
 \tb "individual": "Florian Rabe",\\
 \tb "age": 40,\\
 \tb "concepts": ["instructor", "male"],\\
 \tb "teach": [\\
 \tb\tb\{"name":"Wuv",credits:7.5\},\\
 \tb\tb\{"name":"KRMT",credits:5\}\\
 \tb]\\
\}
}\]


Weirdnesses:
\begin{itemize}
\item atomic/list/record = basic/array/object
\item record field names are arbitrary strings, must be quoted
\item records use $:$ instead of $=$
\end{itemize}
\end{frame}

\begin{frame}\frametitle{Example: YAML}
inline syntax: same as JSON but without quoted field names

alternative: indentation-sensitive syntax
\[\mathll{
 individual: "Florian Rabe"\\
 age: 40\\
 concepts:\\
 \tb  -\; "instructor"\\
 \tb  -\; "male"\\
 teach:\\
 \tb -\; name: "WuV"\\
 \tb\phantom{-}\; credits: 7.5\\
 \tb  -\; name: "KRMT"\
 \tb\phantom{-}\; credits: 5\\
}\]

Weirdnesses:
\begin{itemize}
\item atomic/list/record = scalar/collection/structure
\item records use $:$ instead of $=$
\end{itemize}
\end{frame}

\begin{frame}[fragile]\frametitle{Example: XML}
Weird structure but very similar
\begin{itemize}
\item elements both record (= attributes) and list (= children)
\item elements carry name of type (= tag)
\end{itemize}

\begin{lstlisting}[basicstyle=\footnotesize]
<Person individual="Florian Rabe" age="40">
 <concepts>
   <Concept>instructor</Concept/>
   <Concept>male</Concept/>
 </concepts>
 <teach>
   <Course name="WuV" credits="7.5"/>
   <Course name="KRMT" credits="5"/>
 </teach>
</Person>
\end{lstlisting}

\begin{itemize}
\item Good: \lstinline|Person|, \lstinline|Course|, \lstinline|Concept| give type of object
 \glec{easier to decode}
\item Bad: value of record field must be string
 \glec{concepts cannot be given in attribute}
 \glec{integers, Booleans, whitespace-separated lists coded as strings}
\end{itemize}
\end{frame}

\begin{frame}\frametitle{Structure Sharing}
\begin{blockitems}{Problem}
\item Large objects are often redundant
 \glec{specially when machine-produced}
\item Same string, URL, mathematical objects occurs in multiple places
\item Handled in memory via pointers
\item Size of serialization can explode
\end{blockitems}

\begin{blockitems}{Solution 1: in language}
\item Add definitions to language
 \glec{common part of most languages anyway}
\item Users should introduce name whenever object used twice
\item Problem: only works
 \begin{itemize}
  \item duplication anticipated
  \item users introduced definition
  \item duplication within same context
   \glec{structure-sharing most powerful if across contexts}
 \end{itemize}
\end{blockitems}
\end{frame}

\begin{frame}\frametitle{Structure Sharing (2)}
\begin{blockitems}{Solution 2: in tool}
\item Use factory methods instead of constructors
\item Keep huge hash set of all objects
\item Reuse existing object if already in hash set
\item Advantages
 \begin{itemize}
  \item allows optimization
  \item transparent to users
 \end{itemize}
\item Problem: only works
 \begin{itemize}
  \item for immutable data structures
  \item if no occurrence-specific metadata \glec{e.g., source reference}
 \end{itemize}
\end{blockitems}

\begin{blockitems}{In data representation language}
\item Allow any subobject to carry identifier
\item Allow identifier references as subobjects
\lec{allows preserving structure-sharing in serialization}
\end{blockitems}
\lec{supported by XML, YAML}
\end{frame}

\begin{frame}\frametitle{A Basic Data Representation Language}
Let BDL be given by
\begin{commgrammar}
\gcomment{Data}\\
\gprod{D}{int}{64 bit integers}\\
\galtprod{float}{IEEE double precision floating point}\\
\galtprod{string}{Unicode strings}\\
\galtprod{bool}{true or false}\\
\galtprod{\rep{D}}{lists}\\
\galtprod{\rep{(\ID=D)}}{records}\\
\end{commgrammar}

Exercise 4: Implement BDL using JSON as concrete syntax
\begin{itemize}
 \item data structures
 \item serializer to JSON strings
 \item parser from JSON strings
\end{itemize}
 \glec{you may/should use an existing JSON library}
\end{frame}

\section{Codecs}

\begin{frame}\frametitle{General Definition}
Throughout this section, we fix a data representation language $L$.
\lec{$L$-words called codes}

Given a data type $T$, a codec for $T$ consists
\begin{itemize}
 \item coding function: $c:T \to L$
 \item partial decoding function: $d:L\to T^?$
 \item such that
  \[d(c(x))=x\]
\end{itemize}
\end{frame}

\begin{frame}\frametitle{General Definition}
Given a data type operator $T$ taking $n$ type arguments,\\
a codec operator $C$ for $T$
\begin{itemize}
 \item takes $n$ codecs $C_i$ for $T_i$
 \item returns a codec $C(C_1,\ldots,C_n)$ for $T(T_1,\ldots,T_n)$
\end{itemize}
\end{frame}

\begin{frame}\frametitle{Trivial Codecs}
\begin{itemize}
 \item From now on, we fix $L$ as BDL
 \item Trivial codecs for types close to BDL
\end{itemize}

Examples:
\begin{itemize}
\item \cn{StandardString}: encodes strings as themselves
\item \cn{StandardBool}: encodes booleans as themselves
\item \cn{StandardDobule}: encodes double floats as themselves
\item \cn{StandardInt}: encodes 64-bit integers as themselves
\item \cn{StandardList}$(C)$ for codec $C$ for $T$: codec for $list\,T$ that encodes list $[t_1,\ldots,t_n]$ as BDL-list $C(t_i)$
\end{itemize}

\end{frame}

\end{document}

%%% Local Variables:
%%% mode: latex
%%% TeX-master: t
%%% mode: visual-line
%%% fill-column: 5000
%%% End:

